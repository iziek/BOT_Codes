// Motor control pins
const int motorLeftForward = A0;
const int motorLeftBackward = A1;
const int motorRightForward = A2;
const int motorRightBackward = A3;
const int motorLeftPWM = 9;   // PWM pin for left motor speed
const int motorRightPWM = 10; // PWM pin for right motor speed

// Line sensor pins (index 0 = sensor 5, index 4 = sensor 1)
const int sensorPins[5] = {2,3,4,5,6};  // Reversed sensor order

// Speeds
const int baseSpeed = 100;  // Normal forward speed
const int maxSpeed = 255;   // Maximum PWM speed

// PID constants (tune these)
float Kp = 1000.0;
float Ki = 0.0;
float Kd = 75.0;

// PID variables
float error = 0, lastError = 0;
float integral = 0;
float derivative = 0;
float correction = 0;

// Speed ramping variables
int currentLeftSpeed = 0;
int currentRightSpeed = 0;
int targetLeftSpeed = 0;
int targetRightSpeed = 0;
const int rampStep = 255; // max speed change per loop

// Line lost variables
unsigned long lineLostTime = 0;
bool lineLostActive = false;

// Ramp current speed toward target speed gradually
int rampSpeed(int current, int target) {
  if (current < target) {
    current += rampStep;
    if (current > target) current = target;
  } else if (current > target) {
    current -= rampStep;
    if (current < target) current = target;
  }
  return current;
}

void setup() {
  pinMode(motorLeftForward, OUTPUT);
  pinMode(motorLeftBackward, OUTPUT);
  pinMode(motorRightForward, OUTPUT);
  pinMode(motorRightBackward, OUTPUT);
  pinMode(motorLeftPWM, OUTPUT);
  pinMode(motorRightPWM, OUTPUT);
  for (int i = 0; i < 5; i++) {
    pinMode(sensorPins[i], INPUT);
  }
  delay(2000);
  stopMotors();
}

void stopMotors() {
  digitalWrite(motorLeftForward, LOW);
  digitalWrite(motorLeftBackward, LOW);
  digitalWrite(motorRightForward, LOW);
  digitalWrite(motorRightBackward, LOW);
  analogWrite(motorLeftPWM, 0);
  analogWrite(motorRightPWM, 0);
}

void moveLeftMotor(int speed) {
  if (speed > 0) {
    digitalWrite(motorLeftForward, HIGH);
    digitalWrite(motorLeftBackward, LOW);
    analogWrite(motorLeftPWM, speed);
  } else if (speed < 0) {
    digitalWrite(motorLeftForward, LOW);
    digitalWrite(motorLeftBackward, HIGH);
    analogWrite(motorLeftPWM, -speed);
  } else {
    digitalWrite(motorLeftForward, LOW);
    digitalWrite(motorLeftBackward, LOW);
    analogWrite(motorLeftPWM, 0);
  }
}

void moveRightMotor(int speed) {
  if (speed > 0) {
    digitalWrite(motorRightForward, HIGH);
    digitalWrite(motorRightBackward, LOW);
    analogWrite(motorRightPWM, speed);
  } else if (speed < 0) {
    digitalWrite(motorRightForward, LOW);
    digitalWrite(motorRightBackward, HIGH);
    analogWrite(motorRightPWM, -speed);
  } else {
    digitalWrite(motorRightForward, LOW);
    digitalWrite(motorRightBackward, LOW);
    analogWrite(motorRightPWM, 0);
  }
}

float calculateError() {
  int sensorValues[5];
  int onLineCount = 0;
  long weightedSum = 0;
  for (int i = 0; i < 5; i++) {
    sensorValues[i] = (digitalRead(sensorPins[i]) == LOW) ? 1 : 0;
    if (sensorValues[i]) {
      weightedSum += i * 1000;
      onLineCount++;
    }
  }
  if (onLineCount == 0) {
    return lastError;
  }
  float position = (float)weightedSum / onLineCount;
  return position - 2000;
}

void loop() {
  bool sensors[5];
  int activeSensors = 0;
  for (int i = 0; i < 5; i++) {
    sensors[i] = (digitalRead(sensorPins[i]) == LOW);
    if (sensors[i]) activeSensors++;
  }

  // All black - stop motors
  if (activeSensors == 5) {
    stopMotors();
    lineLostActive = false;
    return;
  }

  // All white - continue last movement for 1.5 sec
  if (activeSensors == 0) {
    if (!lineLostActive) {
      lineLostActive = true;
      lineLostTime = millis();
    }

    if (millis() - lineLostTime <= 1500) {
      // Continue last target speeds
      targetLeftSpeed = currentLeftSpeed;
      targetRightSpeed = currentRightSpeed;
    } else {
      // After 1.5s, move forward slowly
      int slowSpeed = baseSpeed / 2;
      targetLeftSpeed = slowSpeed;
      targetRightSpeed = slowSpeed;
    }
  } else {
    lineLostActive = false;

    // Hard turns: 1 and 5 (index 4 and 0)
    if (sensors[4]) { // sensor 1, hard left
      targetLeftSpeed = 0;            // full backward
      targetRightSpeed = maxSpeed;       // half forward
    } else if (sensors[0]) { // sensor 5, hard right
      targetLeftSpeed = maxSpeed;        // half forward
      targetRightSpeed = 0;            // full backward
    }
    // Soft turns: 2 and 4 (index 3 and 1)
    else if (sensors[3]) { // sensor 2, soft left
      targetLeftSpeed = baseSpeed / 4;        // quarter speed
      targetRightSpeed = baseSpeed;            // full speed
    } else if (sensors[1]) { // sensor 4, soft right
      targetLeftSpeed = baseSpeed;             // full speed
      targetRightSpeed = baseSpeed / 4;        // quarter speed
    }
    else {
      // PID line following
      error = calculateError();

      integral += error;
      derivative = error - lastError;
      correction = Kp * error + Ki * integral + Kd * derivative;

      int leftSpeed = baseSpeed - correction;
      int rightSpeed = baseSpeed + correction;

      targetLeftSpeed = constrain(leftSpeed, -maxSpeed, maxSpeed);
      targetRightSpeed = constrain(rightSpeed, -maxSpeed, maxSpeed);

      lastError = error;
    }
  }

  // Smooth speed ramping
  currentLeftSpeed = rampSpeed(currentLeftSpeed, targetLeftSpeed);
  currentRightSpeed = rampSpeed(currentRightSpeed, targetRightSpeed);

  moveLeftMotor(currentLeftSpeed);
  moveRightMotor(currentRightSpeed);
}
