// ==== Motor Pins ====
const int motorLeftForward = A0;
const int motorLeftBackward = A1;
const int motorRightForward = A2;
const int motorRightBackward = A3;
const int pwmLeft = 9;
const int pwmRight = 10;

// ==== IR Sensors ====
const int sensorPins[5] = {2, 3, 4, 5, 6};
const int sensorWeights[5] = {-4, -2, 0, 2, 4};

// ==== Motor Settings ====
const int baseSpeed = 150;

// ==== Last Move Tracking ====
enum MoveType {FORWARD, SOFT_LEFT, SOFT_RIGHT, HARD_LEFT, HARD_RIGHT, PIVOT_LEFT, PIVOT_RIGHT};
MoveType lastMove = FORWARD;

void setup() {
  pinMode(motorLeftForward, OUTPUT);
  pinMode(motorLeftBackward, OUTPUT);
  pinMode(motorRightForward, OUTPUT);
  pinMode(motorRightBackward, OUTPUT);
  pinMode(pwmLeft, OUTPUT);
  pinMode(pwmRight, OUTPUT);

  for (int i = 0; i < 5; i++) pinMode(sensorPins[i], INPUT);

  Serial.begin(9600);
}

void setLeftMotor(int speed) {
  int s = constrain(abs(speed), 0, 255);
  analogWrite(pwmLeft, s);
  digitalWrite(motorLeftForward, speed > 0);
  digitalWrite(motorLeftBackward, speed < 0);
}

void setRightMotor(int speed) {
  int s = constrain(abs(speed), 0, 255);
  analogWrite(pwmRight, s);
  digitalWrite(motorRightForward, speed > 0);
  digitalWrite(motorRightBackward, speed < 0);
}

void loop() {
  int sensor[5];
  int detected = 0;
  int posSum = 0;

  for (int i = 0; i < 5; i++) {
    sensor[i] = (digitalRead(sensorPins[i]) == LOW) ? 1 : 0;
    if (sensor[i]) {
      detected++;
      posSum += sensorWeights[i];
    }
  }

  int leftSpeed = baseSpeed;
  int rightSpeed = baseSpeed;
  MoveType currentMove = FORWARD;

  // Stop if all sensors detect the line (possible intersection)
  if (detected == 5) {
    setLeftMotor(0);
    setRightMotor(0);
    return;
  }

  // Lost line (no sensors detect line)
  if (detected == 0) {
    switch(lastMove) {
      case FORWARD:
        leftSpeed = baseSpeed; rightSpeed = baseSpeed;
        break;
      case SOFT_LEFT:
        leftSpeed = baseSpeed / 3; rightSpeed = baseSpeed;
        break;
      case SOFT_RIGHT:
        leftSpeed = baseSpeed; rightSpeed = baseSpeed / 3;
        break;
      case HARD_LEFT:
        leftSpeed = 0; rightSpeed = baseSpeed;
        break;
      case HARD_RIGHT:
        leftSpeed = baseSpeed; rightSpeed = 0;
        break;
      case PIVOT_LEFT:
        leftSpeed = -255; rightSpeed = 255;
        break;
      case PIVOT_RIGHT:
        leftSpeed = 255; rightSpeed = -255;
        break;
    }
    setLeftMotor(leftSpeed);
    setRightMotor(rightSpeed);
    return;
  }

  // Pivot turns on outer sensors with reduced speed (softened pivot)
  if (sensor[0]) {
    leftSpeed = -baseSpeed;  // half speed backward
    rightSpeed = baseSpeed / 2 ;  // half speed forward
    currentMove = PIVOT_LEFT;
  } else if (sensor[4]) {
    leftSpeed = baseSpeed / 2;   // half speed forward
    rightSpeed = -baseSpeed; // half speed backward
    currentMove = PIVOT_RIGHT;
  }
  // Increased turn on inner sensors with one motor stopped and the other full speed
  else if (sensor[1]) {
    leftSpeed = baseSpeed / 3;
    rightSpeed = baseSpeed;  // full speed right motor for sharper left turn
    currentMove = SOFT_LEFT;
  } else if (sensor[3]) {
    leftSpeed = baseSpeed;   // full speed left motor for sharper right turn
    rightSpeed = baseSpeed / 3;
    currentMove = SOFT_RIGHT;
  } 
  // Center or mostly center sensor detected, go forward
  else {
    leftSpeed = 200;
    rightSpeed = 255;
    currentMove = FORWARD;
  }

  setLeftMotor(leftSpeed);
  setRightMotor(rightSpeed);
  lastMove = currentMove;
}
