// Motor pins
const int motorLeftForward = A0;
const int motorLeftBackward = A1;
const int motorRightForward = A2;
const int motorRightBackward = A3;
const int pwmLeft = 9;
const int pwmRight = 10;

// Ultrasonic sensor pins
const int trigPin = 12;
const int echoPin = 13;

// IR sensor pins for edge detection (black line detected = LOW)
const int sensorPins[5] = {2, 3, 4, 5, 6};

// Motor speed settings
const int baseSpeed = 100;        // Speed for turning in place during oscillation
const int attackSpeed = 255;      // Full speed attack
const int retreatSpeed = 150;     // Speed for retreating on edge detection

// Ultrasonic detection distance (cm)
const int opponentDistanceThreshold = 30; // ~12 inches

// Oscillation variables
bool turnLeft = true;
unsigned long lastTurnTime = 0;
const unsigned long leftTurnInterval = 1000;   // milliseconds (turn left duration)
const unsigned long rightTurnInterval = 1000;  // milliseconds (turn right duration)

// State machine definition
enum RobotState { SEARCHING, RETREATING, ATTACKING };
RobotState currentState = SEARCHING;

unsigned long retreatStartTime = 0;
const unsigned long retreatDuration = 300;  // retreat backward duration in ms
const unsigned long turnDuration = 500;     // retreat turn duration in ms

void setup() {
  pinMode(motorLeftForward, OUTPUT);
  pinMode(motorLeftBackward, OUTPUT);
  pinMode(motorRightForward, OUTPUT);
  pinMode(motorRightBackward, OUTPUT);
  pinMode(pwmLeft, OUTPUT);
  pinMode(pwmRight, OUTPUT);

  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);

  for (int i = 0; i < 5; i++) {
    pinMode(sensorPins[i], INPUT);
  }

  Serial.begin(9600);

  lastTurnTime = millis(); // Ensure full initial turn interval
}

void setLeftMotor(int speed) {
  if (speed > 0) {
    analogWrite(pwmLeft, speed);
    digitalWrite(motorLeftForward, HIGH);
    digitalWrite(motorLeftBackward, LOW);
  } else if (speed < 0) {
    analogWrite(pwmLeft, -speed);
    digitalWrite(motorLeftForward, LOW);
    digitalWrite(motorLeftBackward, HIGH);
  } else {
    analogWrite(pwmLeft, 0);
    digitalWrite(motorLeftForward, LOW);
    digitalWrite(motorLeftBackward, LOW);
  }
}

void setRightMotor(int speed) {
  if (speed > 0) {
    analogWrite(pwmRight, speed);
    digitalWrite(motorRightForward, HIGH);
    digitalWrite(motorRightBackward, LOW);
  } else if (speed < 0) {
    analogWrite(pwmRight, -speed);
    digitalWrite(motorRightForward, LOW);
    digitalWrite(motorRightBackward, HIGH);
  } else {
    analogWrite(pwmRight, 0);
    digitalWrite(motorRightForward, LOW);
    digitalWrite(motorRightBackward, LOW);
  }
}

// Ultrasonic read function (cm)
long readUltrasonicDistance() {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long duration = pulseIn(echoPin, HIGH, 30000); // 30ms timeout
  long distance = duration * 0.034 / 2; // cm
  return distance;
}

void loop() {
  long distance = readUltrasonicDistance();

  // Check for edge detection: any sensor detecting black line (LOW)
  bool edgeDetected = false;
  for (int i = 0; i < 5; i++) {
    if (digitalRead(sensorPins[i]) == LOW) {
      edgeDetected = true;
      break;
    }
  }

  Serial.print("Distance: ");
  Serial.print(distance);
  Serial.print(" cm, Edge: ");
  Serial.print(edgeDetected);
  Serial.print(", State: ");
  Serial.println(currentState);

  unsigned long currentTime = millis();

  switch (currentState) {
    case SEARCHING:
      if (edgeDetected) {
        currentState = RETREATING;
        retreatStartTime = currentTime;
        setLeftMotor(-retreatSpeed);
        setRightMotor(-retreatSpeed);
      }
      else if (distance > 0 && distance <= opponentDistanceThreshold) {
        currentState = ATTACKING;
        setLeftMotor(attackSpeed);
        setRightMotor(attackSpeed);
      }
      else {
        unsigned long interval = turnLeft ? leftTurnInterval : rightTurnInterval;
        if (currentTime - lastTurnTime >= interval) {
          turnLeft = !turnLeft;
          lastTurnTime = currentTime;
        }
        if (turnLeft) {
          setLeftMotor(baseSpeed);
          setRightMotor(-baseSpeed);
        } else {
          setLeftMotor(-baseSpeed);
          setRightMotor(baseSpeed);
        }
      }
      break;

    case RETREATING:
      if (currentTime - retreatStartTime < retreatDuration) {
        setLeftMotor(-retreatSpeed);
        setRightMotor(-retreatSpeed);
      }
      else if (currentTime - retreatStartTime < retreatDuration + turnDuration) {
        setLeftMotor(-retreatSpeed);
        setRightMotor(retreatSpeed);
      }
      else {
        setLeftMotor(0);
        setRightMotor(0);
        currentState = SEARCHING;
        turnLeft = true;
        lastTurnTime = currentTime;
      }
      break;

    case ATTACKING:
      if (edgeDetected) {
        currentState = RETREATING;
        retreatStartTime = currentTime;
        setLeftMotor(-retreatSpeed);
        setRightMotor(-retreatSpeed);
      }
      else if (distance == 0 || distance > opponentDistanceThreshold) {
        currentState = SEARCHING;
        turnLeft = true;
        lastTurnTime = currentTime;
      }
      else {
        setLeftMotor(attackSpeed);
        setRightMotor(attackSpeed);
      }
      break;
  }

  delay(20);
}
